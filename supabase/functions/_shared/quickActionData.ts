// Data fetching helpers for Quick Actions
// Fetches watchlist, portfolio, market data, signals, etc.

import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2.38.0";
import { fetchQuote, fetchBulkQuotes } from "./yahoo_v8_client.ts";

export interface WatchlistStock {
  symbol: string;
  added_at: string;
}

export interface PortfolioPosition {
  symbol: string;
  quantity: number;
  cost_basis: number;
  current_value?: number;
  unrealized_pnl?: number;
}

export interface MarketDataPoint {
  symbol: string;
  price: number | null;
  change: number | null;
  changePercent: number | null;
  volume: number | null;
}

export interface TradeSignal {
  symbol: string;
  signal_type: string;
  confidence: number;
  timeframe: string;
  created_at: string;
}

export interface SectorPerformance {
  sector: string;
  performance_pct: number;
  trend: string;
}

/**
 * Fetch user's watchlist symbols
 */
export async function fetchWatchlistData(
  supabase: SupabaseClient,
  userId: string
): Promise<WatchlistStock[]> {
  try {
    const { data, error } = await supabase
      .from("user_watchlist")
      .select("symbol, added_at")
      .eq("user_id", userId)
      .order("added_at", { ascending: false })
      .limit(20);

    if (error) {
      console.error("[fetchWatchlistData] Error:", error);
      return [];
    }

    return data as WatchlistStock[];
  } catch (error) {
    console.error("[fetchWatchlistData] Unexpected error:", error);
    return [];
  }
}

/**
 * Fetch user's portfolio positions
 * Note: Table structure may vary - adjust as needed
 */
export async function fetchPortfolioData(
  supabase: SupabaseClient,
  userId: string
): Promise<PortfolioPosition[]> {
  try {
    // Check if portfolio table exists
    const { data, error } = await supabase
      .from("user_portfolio")
      .select("symbol, quantity, cost_basis")
      .eq("user_id", userId)
      .limit(50);

    if (error) {
      console.error("[fetchPortfolioData] Error (table may not exist):", error);
      return [];
    }

    return data as PortfolioPosition[];
  } catch (error) {
    console.error("[fetchPortfolioData] Unexpected error:", error);
    return [];
  }
}

/**
 * Fetch market data for multiple symbols using Yahoo Finance
 */
export async function fetchMarketData(
  symbols: string[]
): Promise<MarketDataPoint[]> {
  if (symbols.length === 0) return [];

  console.log(`[fetchMarketData] Fetching real-time data for ${symbols.length} symbols`);

  // Use Yahoo Finance API to fetch real quotes
  const quotesMap = await fetchBulkQuotes(symbols);
  
  const results: MarketDataPoint[] = symbols.map((symbol) => {
    const quote = quotesMap[symbol.toUpperCase()];
    if (!quote) {
      console.warn(`[fetchMarketData] No data for ${symbol}`);
      return {
        symbol,
        price: null,
        change: null,
        changePercent: null,
        volume: null,
      };
    }
    
    return {
      symbol: quote.symbol,
      price: quote.price,
      change: quote.change,
      changePercent: quote.changePercent,
      volume: quote.volume,
    };
  });

  console.log(`[fetchMarketData] Successfully fetched ${results.filter(r => r.price !== null).length}/${symbols.length} quotes`);
  return results;
}

/**
 * Fetch signals from ai_signals table (generated by hourly cron)
 */
export async function fetchSignalsData(
  supabase: SupabaseClient,
  filter?: "bullish" | "bearish" | "breakout" | "oversold",
  limit = 20
): Promise<TradeSignal[]> {
  try {
    console.log(`[fetchSignalsData] Querying ai_signals with filter: ${filter}, limit: ${limit}`);
    
    let query = supabase
      .from("ai_signals")
      .select("symbol, signal_type, confidence_final, timeframe, updated_at")
      .order("updated_at", { ascending: false })
      .limit(limit * 2); // Fetch more to account for filtering

    // Apply filter based on signal type
    // ai_signals uses: 'buy' | 'sell' | 'neutral'
    if (filter === "bullish") {
      query = query.eq("signal_type", "buy");
    } else if (filter === "bearish") {
      query = query.eq("signal_type", "sell");
    } else if (filter === "breakout") {
      // Breakout signals are 'buy' signals with high confidence
      query = query.eq("signal_type", "buy").gte("confidence_final", 70);
    } else if (filter === "oversold") {
      // Oversold signals are 'buy' signals with lower confidence (potential reversals)
      query = query.eq("signal_type", "buy").lt("confidence_final", 70);
    }

    const { data, error } = await query;

    if (error) {
      console.error("[fetchSignalsData] Error:", error);
      return [];
    }

    if (!data || data.length === 0) {
      console.log(`[fetchSignalsData] No signals found for filter: ${filter}`);
      return [];
    }

    // Map ai_signals schema to TradeSignal format
    const signals = data.slice(0, limit).map((row: any) => ({
      symbol: row.symbol,
      signal_type: row.signal_type.toUpperCase(),
      confidence: row.confidence_final,
      timeframe: row.timeframe,
      created_at: row.updated_at,
    }));

    console.log(`[fetchSignalsData] Found ${signals.length} signals`);
    return signals as TradeSignal[];
  } catch (error) {
    console.error("[fetchSignalsData] Unexpected error:", error);
    return [];
  }
}

/**
 * Fetch sector performance data
 * Uses real-time data from sector ETFs
 */
export async function fetchSectorData(): Promise<SectorPerformance[]> {
  console.log('[fetchSectorData] Fetching real sector performance data');

  // Sector ETF mapping (SPDR sectors)
  const sectorETFs = [
    { symbol: "XLK", sector: "Technology" },
    { symbol: "XLV", sector: "Healthcare" },
    { symbol: "XLF", sector: "Financials" },
    { symbol: "XLE", sector: "Energy" },
    { symbol: "XLY", sector: "Consumer Discretionary" },
    { symbol: "XLI", sector: "Industrials" },
    { symbol: "XLB", sector: "Materials" },
    { symbol: "XLU", sector: "Utilities" },
    { symbol: "XLRE", sector: "Real Estate" },
    { symbol: "XLC", sector: "Communication Services" },
  ];

  const symbols = sectorETFs.map(s => s.symbol);
  const quotesMap = await fetchBulkQuotes(symbols);

  const sectors: SectorPerformance[] = sectorETFs.map(({ symbol, sector }) => {
    const quote = quotesMap[symbol];
    const performance_pct = quote?.changePercent ?? 0;
    
    let trend = "neutral";
    if (performance_pct > 0.5) trend = "up";
    else if (performance_pct < -0.5) trend = "down";

    return {
      sector,
      performance_pct,
      trend,
    };
  });

  console.log(`[fetchSectorData] Fetched ${sectors.length} sector performances`);
  return sectors;
}

/**
 * Fetch upcoming earnings calendar
 * Note: Yahoo Finance doesn't provide earnings calendar via free API
 * Returns empty array - integrate with paid calendar API if needed
 */
export async function fetchEarningsData(): Promise<{ symbol: string; date: string }[]> {
  console.log('[fetchEarningsData] Earnings calendar not available via Yahoo API');
  // TODO: Integrate with a paid earnings calendar API (e.g. Alpha Vantage, Financial Modeling Prep)
  return [];
}

/**
 * Helper to enrich watchlist/portfolio symbols with market data
 */
export async function enrichSymbolsWithMarketData(
  symbols: string[]
): Promise<Array<{ symbol: string; quote: MarketDataPoint }>> {
  const marketData = await fetchMarketData(symbols);
  return symbols.map((symbol) => ({
    symbol,
    quote: marketData.find((d) => d.symbol === symbol) ?? {
      symbol,
      price: null,
      change: null,
      changePercent: null,
      volume: null,
    },
  }));
}
