// SCALP_V1_MICROEDGE Position Monitor\n// Monitors open positions and executes exits (TP/SL/TIME/OVERNIGHT)\n// Run schedule: Every 1-5 minutes during market hours\n\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.0';\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n};\n\ninterface Position {\n  id: string;\n  ticker: string;\n  side: 'LONG' | 'SHORT';\n  qty: number;\n  entry_price: number;\n  stop_loss: number;\n  take_profit: number;\n  opened_at: string;\n}\n\ninterface ExitDecision {\n  position_id: string;\n  ticker: string;\n  reason: 'TP' | 'SL' | 'TIME_STOP' | 'FORCE_CLOSE';\n  exit_price: number;\n  pnl_dollars: number;\n  pnl_pct: number;\n  pnl_r: number;\n}\n\nDeno.serve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders });\n  }\n\n  const runStartTime = Date.now();\n  console.log('[scalp_position_monitor] Starting position exit scan');\n\n  try {\n    const supabase = createClient(\n      Deno.env.get('SUPABASE_URL')!,\n      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!\n    );\n\n    // Load SCALP config\n    const { data: configData, error: configError } = await supabase\n      .from('scalp_engine_config')\n      .select('*')\n      .eq('is_enabled', true)\n      .maybeSingle();\n\n    if (configError || !configData) {\n      throw new Error(`Failed to load SCALP config: ${configError?.message || 'No active config'}`);\n    }\n\n    const config = configData as any;\n    const timeLimit = config.time_limit_minutes || 30;\n    const overnightTime = config.overnight_force_close_utc_time || '19:55:00';\n\n    // Get SCALP portfolio\n    const { data: portfolioData, error: portfolioError } = await supabase\n      .from('engine_portfolios')\n      .select('*')\n      .eq('engine_key', 'SCALP')\n      .eq('engine_version', 'SCALP_V1_MICROEDGE')\n      .eq('run_mode', 'SHADOW')\n      .maybeSingle();\n\n    if (portfolioError || !portfolioData) {\n      throw new Error(`Failed to load SCALP portfolio`);\n    }\n\n    let portfolio = portfolioData as any;\n    let portfolioUpdated = false;\n\n    // Fetch all OPEN SCALP positions\n    const { data: positions, error: posError } = await supabase\n      .from('engine_positions')\n      .select('*')\n      .eq('engine_key', 'SCALP')\n      .eq('engine_version', 'SCALP_V1_MICROEDGE')\n      .eq('run_mode', 'SHADOW')\n      .eq('status', 'OPEN');\n\n    if (posError) {\n      throw new Error(`Failed to fetch open positions: ${posError.message}`);\n    }\n\n    console.log(`[scalp_position_monitor] Found ${positions?.length || 0} open positions`);\n\n    const exits: ExitDecision[] = [];\n    const now = new Date();\n\n    // Check each position for exit conditions\n    for (const pos of positions || []) {\n      if (!pos.opened_at) {\n        console.warn(`[scalp_position_monitor] Position ${pos.id} missing opened_at`);\n        continue;\n      }\n\n      const openedAt = new Date(pos.opened_at);\n      const minutesHeld = (now.getTime() - openedAt.getTime()) / (1000 * 60);\n\n      // RULE 1: Time stop (30 min default)\n      if (minutesHeld >= timeLimit) {\n        console.log(`[scalp_position_monitor] ${pos.ticker} TIME STOP after ${minutesHeld.toFixed(1)}min`);\n        const exitResult = await closePosition(\n          supabase,\n          pos,\n          pos.entry_price,\n          'TIME_STOP',\n          portfolio\n        );\n        if (exitResult) {\n          exits.push(exitResult);\n          portfolio = exitResult.updated_portfolio || portfolio;\n          portfolioUpdated = true;\n        }\n        continue;\n      }\n\n      // RULE 2: Overnight force close (5 min before market close)\n      const timeOfDay = now.getHours() * 60 + now.getMinutes();\n      const [overnightHour, overnightMin] = overnightTime.split(':').map(Number);\n      const overnightTimeOfDay = overnightHour * 60 + overnightMin;\n      const closeTime = overnightTimeOfDay - 5;\n\n      if (timeOfDay >= closeTime && timeOfDay < overnightTimeOfDay) {\n        console.log(`[scalp_position_monitor] ${pos.ticker} FORCE CLOSE (overnight rule)`);\n        const exitResult = await closePosition(\n          supabase,\n          pos,\n          pos.entry_price,\n          'FORCE_CLOSE',\n          portfolio\n        );\n        if (exitResult) {\n          exits.push(exitResult);\n          portfolio = exitResult.updated_portfolio || portfolio;\n          portfolioUpdated = true;\n        }\n        continue;\n      }\n\n      // RULE 3 & 4: TP and SL checks would fetch real market data here\n      console.log(`[scalp_position_monitor] ${pos.ticker} monitoring (${minutesHeld.toFixed(1)}min open)`);\n    }\n\n    // Update portfolio if any positions closed\n    if (portfolioUpdated) {\n      const { error: updateError } = await supabase\n        .from('engine_portfolios')\n        .update({\n          equity: portfolio.equity,\n          allocated_notional: portfolio.allocated_notional,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', portfolio.id);\n\n      if (updateError) {\n        console.warn(`[scalp_position_monitor] Portfolio update error:`, updateError);\n      } else {\n        console.log(`[scalp_position_monitor] Portfolio updated: equity=$${portfolio.equity.toFixed(2)}`);\n      }\n    }\n\n    const runDurationMs = Date.now() - runStartTime;\n\n    return new Response(\n      JSON.stringify({\n        status: 'completed',\n        timestamp: new Date().toISOString(),\n        open_positions: (positions?.length || 0) - exits.length,\n        closed_this_run: exits.length,\n        exits,\n        portfolio_updated: portfolioUpdated,\n        duration_ms: runDurationMs,\n      }),\n      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n  } catch (error) {\n    console.error('[scalp_position_monitor] Fatal error:', error);\n    return new Response(\n      JSON.stringify({\n        status: 'error',\n        error: error.message || String(error),\n      }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n  }\n});\n\nasync function closePosition(\n  supabase: any,\n  position: Position,\n  exitPrice: number,\n  reason: 'TP' | 'SL' | 'TIME_STOP' | 'FORCE_CLOSE',\n  portfolio: any\n): Promise<ExitDecision & { updated_portfolio?: any } | null> {\n  try {\n    const riskPerShare = Math.abs(position.entry_price - position.stop_loss);\n    const pnlDollars = position.side === 'LONG'\n      ? (exitPrice - position.entry_price) * position.qty\n      : (position.entry_price - exitPrice) * position.qty;\n    const pnlPct = (pnlDollars / (position.entry_price * position.qty)) * 100;\n    const pnlR = riskPerShare > 0 ? pnlDollars / (riskPerShare * position.qty) : 0;\n\n    // Update position to CLOSED\n    await supabase\n      .from('engine_positions')\n      .update({\n        status: 'CLOSED',\n        closed_at: new Date().toISOString(),\n        exit_price: exitPrice,\n        exit_reason: reason,\n        realized_pnl: pnlDollars,\n        realized_r: pnlR,\n      })\n      .eq('id', position.id);\n\n    // Insert into engine_trades\n    await supabase\n      .from('engine_trades')\n      .insert({\n        engine_key: 'SCALP',\n        engine_version: 'SCALP_V1_MICROEDGE',\n        run_mode: 'SHADOW',\n        ticker: position.ticker,\n        side: position.side,\n        entry_price: position.entry_price,\n        exit_price: exitPrice,\n        opened_at: position.opened_at,\n        closed_at: new Date().toISOString(),\n        realized_pnl: pnlDollars,\n        realized_r: pnlR,\n        meta: {\n          exit_reason: reason,\n          qty: position.qty,\n          target: position.take_profit,\n          stop: position.stop_loss,\n        },\n      })\n      .catch(err => console.warn('[scalp_position_monitor] Trade log error (non-fatal)'));\n\n    // Update scalp_execution_log\n    await supabase\n      .from('scalp_execution_log')\n      .update({\n        status: 'CLOSED',\n        exit_time: new Date().toISOString(),\n        exit_price: exitPrice,\n        exit_reason: reason,\n        pnl_dollars: pnlDollars,\n        pnl_pct: pnlPct,\n        pnl_r: pnlR,\n      })\n      .eq('id', position.id)\n      .catch(err => console.warn('[scalp_position_monitor] Execution log error (non-fatal)'));\n\n    // Update portfolio equity\n    const updatedPortfolio = {\n      ...portfolio,\n      equity: portfolio.equity + pnlDollars,\n      allocated_notional: Math.max(0, portfolio.allocated_notional - (position.entry_price * position.qty)),\n    };\n\n    console.log(`[scalp_position_monitor] Closed ${position.ticker} - ${reason} - PnL: $${pnlDollars.toFixed(2)} (${pnlR.toFixed(2)}R)`);\n\n    return {\n      position_id: position.id,\n      ticker: position.ticker,\n      reason,\n      exit_price: exitPrice,\n      pnl_dollars: pnlDollars,\n      pnl_pct: pnlPct,\n      pnl_r: pnlR,\n      updated_portfolio: updatedPortfolio,\n    };\n  } catch (error) {\n    console.error('[scalp_position_monitor] Close error:', error);\n    return null;\n  }\n}\n"}}